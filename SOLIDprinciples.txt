 - - - Single responsibility - принцип единственной ответственности.
Смысл заключается в том, что любой метод должен нести в себе одну единственную функцию. Если метод, например, делает вычисления и после этого выводит результаты на экран - этот принцип нарушен. Один метод - одна функция.
Этот же принцип касается и классов. Если мы создаем класс с методами для создания картинки, то в этот класс не должны попадать такие функции как сохранение картинки в файл, отправка на почтовый ящик и т.п. При тестировании таких наполненных разным функционалом классов возникнет много трудностей.
Исполнением данного принципа является декомпозиция. Т.е. мы берем, даже простую, как нам кажется, систему и стараемся её разделить на какие-то супер простые части. Но, нужно не забывать, что часто встречается общий функционал, который следует наоборот обобщать (т.е. выносить общий функционал в отдельный метод или класс, в зависимости от ситуации).

 - - - Open-closed - принцип открытости / закрытости.
Базируется на двух принципах:
I) Каждая сущность закрыта для изменений (нельзя вносить изменения в код, который используется).
Если какая-то сущность уже описана, то она должна быть закрыта для каких-либо изменений. Это связано с тем, что программы пишутся командно. После того, как первый программист написал свой модуль, второй может писать свой код на основе первого. Если же, через какое-то время, первый программист решит внести небольшие изменения в свой первоначальный код, это может принести огромную кучу ошибок в коде у второго программиста.
II) Сущность открыта для модификаций (поведение сущности может быть расширено).
Этот принцип призывает к реализации через интерфейсы и абстрактные классы, которые можно в последующем расширять. Пример с сохранением картинки в разных форматах. Для этого мы создали функциональный интерфейс с последующей имплементацией в абстрактном классе, от которого наследовалось три новых класса с различной реализацией кодирования формата изображения. А в классе самой картинки было создано поле абстрактного класса, чтобы в последующем можно было выбрать каким методом кодировать данное изображение.
________________________________________
public interface SaveImage {
    void saveImg();
}
________________________________________
public abstract class FormatDecoder implements SaveImage{

}
________________________________________
public class SaveInJPEG extends FormatDecoder{
    @Override
    public void saveImg() {
        System.out.println(" --> JPEG"); // реализация кодирования изображения
    }
}
________________________________________
public class SaveInPNG extends FormatDecoder{
    @Override
    public void saveImg() {
        System.out.println(" --> PNG");
    }
}
________________________________________
public class Image {
    private int width;
    private int height;
    private FormatDecoder formatDecoder;

    public Image(int width, int height, FormatDecoder formatDecoder) {
        this.width = width;
        this.height = height;
        this.formatDecoder = formatDecoder;
    }

    public FormatDecoder getFormatDecoder() {
        return formatDecoder;
    }
}
________________________________________
public class Main {
    public static void main(String[] args) {
        Image image = new Image(23, 23, new SaveInJPEG());
        image.getFormatDecoder().saveImg();
    }
}
________________________________________ 

 - - - Barbara Liskov
Описание примера из видео Сергея Камяницкого:
Допустим, есть класс Bird. В этом классе имеется метод fly. Но мы знаем, что есть такие птицы, которые не летают. Соответственно, им не особенно подходит описание данного класса. А есть птицы, которые прекрасно плавают и не летают, а есть которые летают и плавают и т.д. Барбара Лисков утверждает, что система должна работать таким образом, что, даже если мы подставляем класс потомок вместо родительского класса, система должна работать корректно. Потому, для решения данного вопроса нужно пребегнуть к реализации метода move() в классе Bird. А уже у потомков определять реализацию этого метода по-своему.
 
 - - - Interface segregation - принцип разделения интерфейса.
Суть принципа: клиенты не должны зависеть от методов, которые они не используют. Т.е. следует использовать необходимый минимум реализаций методов.
Хороший пример - сравнение сайтов продажи автомобилей Lada и Audi. Разница в том, что Лада предлагает готовое решение в котором клиент не может внести собственные изменения. А сайт Ауди позволяет выбрать как вариант, где сам клиент выбирает всю комплектацию, так и вариант, где можно выбрать определенный пакет. Но ко всему, при выборе пакета, есть возможность дополнить какими-то фишками свой выбор.

 - - - Dependency Inversion - принцип инверсии зависимостей используется для уменьшения связности сущностей между собой.
Модули верхних уровней не должны зависеть от модулей нижних уровней.